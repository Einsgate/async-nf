\section{Introduction}

Network Functions (NFs) are more than simple packet processors that perform stateless header transformation for each received packet, modern NFs need to carry out stateful processing for L4 TCP/UDP flows. To implement efficient L4 flow processing, NF must fully utilize flow-level asynchrony: after processing a packet for a single flow, the NF can move on to process packets for other flows without worrying about disturbing the original flow. Various NF software \cite{snort, 201546, haproxy} uses event-driven programming to address flow-level asynchrony. After finish processing a flow, a micro context is saved for the flow and the NF switches to process other flows. When interested events happen for the flow, i.e. new TCP payload arrives, the saved context is resumed and a pre-determined callback functions are called to serve the event.

Besides flow-level asynchrony, modern NFs even need to address request-level asynchrony by contacting external services, so that they can be resilient to failures \cite{201545}, collaborate with other NFs \cite{3gpp-ims} and retrieve encrypted information \cite{sherry2015blindbox}. For instance, StatelessNF \cite{201545} needs to retrieve important flow session state from a remote database \cite{ousterhout2015ramcloud} when processing the packets, so that even if the NF instances are failed, they can be quickly recovered. To ensure high-performance, the NF should not halt block waiting for the response, it should switch to process other flow packets, or handle other requests. Event-driven programming has a long history for addressing request-level asynchrony: the application registers a callback function to a pollable interface (Linux epoll). When the response arrives, the pollable interface invokes the callback function to handle the response.

The callback-based event-driven programming model has a long successful history, however, it still has some major draw backs when being used to develop NFs. First, the packet access pattern of a NF sometimes requires multiple asynchronous operations to be chained together in order to process a single packet \cite{201545}. This requires defining multiple callback functions and saving multiple contexts, which may significantly increase the number of the lines of code used for implementing simple NF logic. Second, due to the use of multiple callback functions, the control flow of the program is disrupted, making it hard to write and reason about the correctness of the resulting NF logic. Third, exception handling in existing event-driven framework can be repetitive, as each callback function needs to carefully handle possible error conditions. Finally, most existing event-driven programming framework is based on C programming language, which does not expose a safe programming interface. When the callback function is invoked, the callback function can literarlly modify arbitrary program state, which may crash the entire NF program if not carefully programmed.

In this paper, we proposed NetStar framework, which is designed to improve asynchronous programming in NF software. In particular, NetStar handles asynchronous operations of middleboxes in a way that is both efficient and manageable. Asynchronous operations in NetStar are accomplished through through callbacks, making NetStar highly efficient. However, the callbacks in NetStar are used in an implicit way that mimics the style of synchronous operations, making them easy to program with and reason about. NetStar's power comes from the promise-continuation programming model provided by Seastar \cite{seastar} and advanced C++14 features, such as lambda expression and move semantics.

Based on the advanced programming model, we design a general purpose asynchronous flow abstraction that can precisely capture a wide rage of real-world NF requirements. Using the asynchronous flow abstraction, the processing task of the flow can pause at any time to perform asynchronous operations and resume normal processing when the asynchronous operation finishes. Our model is memory safe and only exposes events that the user registers.

We build several NFs with NetStar that capture a wide range of research and real-world needs, including an improved StatelessNF re-implementation, an HTTP proxy, an IDS and a SIP proxy used in IMS system. We show that NFs implemented in NetStar delivers sufficiently good performance in terms of packet processing throughput and latency. Moreoever, we quantitatively evaluate the quality of the source code of NFs implemented using NetStar with NFs implemented using traditional call-backed event-driven programming model. Our quantitative study shows that for NFs that need to perform asynchronous operations, NetStar can significantly reduce the lines of code needed to implement the NF, reduce the number of the function definitions and reduce the lines of code that are devoted to error handling.

We make the following contribution in this paper:

First, we extend Seastar into a new framework for efficiently building asynchronous NFs. Second, we define a general purpose asynchronous flow model that can capture the requirement of a wide-range of real-world middleboxes. Finally, we use NetStar to build some practical middleboxes and quantitatively evaluate its effectiveness in reducing the lines of implementation code.
